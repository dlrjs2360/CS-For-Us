# 📌 <span style= "color: lightgreen"> 최단 경로 알고리즘

---
## 🌿 1. 다익스트라 (Dijkstra)

###  1-1. 개념
- <span style= "color: lightblue"> 그래프에서 한 정점(노드)에서 다른 모든 정점까지의 최단 경로룰 구하는 대표적인 알고리즘</span>
- 최단 경로 알고리즘 중 하나

### 1-2. 동작 단계
``` markdown
1. 출발 노드를 설정하고 `최단 거리 테이블`을 초기화한다.
2. 현재 노드에서 이동할 수 있는 노드들 중 가장 가까운 노드를 선택한다. 
3. 해당 노드를 거쳐 다른 노드로 넘어가는 비용을 계산하여 `최단 거리 테이블`을 갱신한다.
4. 3~4의 과정을 반복한다.
```

### 1-3. 구현
<u>다익스트라의 핵심은 현재 노드에서 가장 가까운 노드를 선택하여 이동하는 것이다.</u>

일종의 그리디(Greedy)알고리즘에 속하며 각 단계에서 최적의 선택을 통해 최적의 해를 만들어낸다.

기본적인 다익스트라 알고리즘은 BFS와 마찬가지로 방문처리 배열을 만들고 노드를 방문할 때마다 방문처리를 해야 하지만 `우선순위큐(Priority Queue)`를 사용하여 구현하면 방문처리가 필요없어진다.
``` markdown
1. 최단 거리 테이블 생성
   - 최단 거리 테이블은 거리를 더 작은 방향으로 갱신해야 하므로 기본값을 최대값으로 설정한다.
   - 출발 노드에서 다른 노드들까지의 최단 거리를 구하기 때문에 1차원 배열로 생성한다.
   - 출발 노드는 0으로 초기화한다.
2. 우선순위큐에서 가장 거리가 짧은 정점을 꺼내서 거리를 비교한다.
   - 우선순위큐의 초기값을 시작점 하나이다.
   - (시작점 -> 이전노드) + (이전노드 -> 현재노드)의 거리가 (시작점 -> 현재노드)보다 짧다면 거리를 갱신해주고 우선순위큐에 다시 넣어준다.
   - 다시 넣어주는 이유는 해당 노드까지의 거리가 갱신됨에 따라 해당 노드와 연결된 다른 노드들까지의 거리도 갱신될 수 있기 때문이다.
3. 우선순위큐가 비어질 때까지 3번 과정을 반복한다.
```

### 1-4. 시간복잡도와 공간복잡도

그래프의 노드(점)의 수 = V, 간선의 수 = E

- 시간복잡도
  - <span style = "color:skyblue">**O((V+E) log V) == O(VlogV)**</span>
- 공간복잡도
  - O(V+E)

### 1-5. 문제 링크
1. <a href = "https://www.acmicpc.net/problem/10282"> (해킹 / 골드4)</a>
2. <a href = "https://www.acmicpc.net/problem/1504"> (특정한 최단 경로 / 골드4)</a>
3. <a href = "https://www.acmicpc.net/problem/1238"> (파티 / 골드3)</a>
4. <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/132266"> (부대 복귀 / LV3)</a>

---
## 🌿 2. 플로이드-워샬
### 2-1. 개념
- <span style= "color: lightblue"> 그래프의 모든 정점에서 다른 모든 정점으로 향하는 최단 거리를 구하는 알고리즘 </span>
- `다익스트라`는 한 정점에서 다른 모든 정점으로의 최단 거리를 구한다면 `플로이드-워샬`은 모든 정점에서의 다익스트라 결과값을 구한다.

### 2-2. 동작 단계
- <u>`플로이드-워샬`은 다이나믹 프로그래밍 기법을 사용하여 동작하며, 그래프의 각 정점을 중간 정점을 사용하여 최단 경로를 업데이트한다.</u>
```
1. 초기 그래프 설정
  - 주어진 그래프의 인접 행렬을 설정한다.
  - 두 정점 사이의 간선이 존재하지 않는다면 두 정점 사이의 값을 무한대로 설정한다. 또한 자기 자신으로의 거리는 0으로 설정한다.
2. 중간 정점 선택
  - 모든 정점들을 탐색하며 각 정점을 중간 정점으로 선택한다.
  - (A -> B) 라는 경로가 있을 때, (A -> K -> B)의 경로를 탐색하는 것이다.
3. 최단 경로 갱신
  - (A -> B)의 거리가 d(A,B)일 때, d(A,B) = Min(d(A,B), d(A,K) + d(K,B)) 이다.
  - 즉, A에서 B라는 정점으로 향할 때, K 정점을 거쳐서 이동하는 거리가 더 짧다면 최단 거리를 갱신해주는 것이다.
  - 이를 모든 중간 정점 k에 대해서 반복한다.
4. 이제 d(A,B)는 A에서 어떤 정점을 거치더라도 B로 향하는 최단거리가 저장되어 있다.
```

### 2-3. 시간복잡도와 공간복잡도

그래프의 노드(점)의 수 = V, 간선의 수 = E

- 시간복잡도
  - 중간 정점 반복(V) * 출발 정점 반복(V) * 도착 정점 반복(V) = <span style = "color:skyblue">**O(V^3)**</span>
- 공간복잡도
  - 일반적으로 `d[출발정점][도착정점]`으로 최단거리를 저장 == O(V^2)

### 2-4. 문제 링크
- <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/72413"> (합승 택시 요금 / LV3)</a>
- <a href = "https://www.acmicpc.net/problem/11404"> (플로이드 / 골드4)</a>
- <a href = "https://www.acmicpc.net/problem/1956"> (운동 / 골드4)</a>

---
## 🌿 3. 벨만-포드 
### 3-1. 개념
- <span style= "color: lightblue"> 그래프의 한 정점에서 다른 모든 정점으로 향하는 최단거리를 구하는 알고리즘 </span>
- 다익스트라와의 차이점은 <u>`벨만-포드`는 음의 간선을 포함할 수 있다는 것이다.</u>

### 3-2. 동작 단계
- `벨만-포드` 알고리즘은 음수 싸이클을 탐지하여 최단 거리 정의 가능여부를 확인한다.
```markdown
1. 그래프 초기화
    - 주어진 그래프의 각 정점에 대하여 최단 거리 값을 무한대로 초기화한다.
    - 시작 정점의 최단 거리는 0으로 설정한다.
2. 간선 순회
    - 모든 간선을 탐색하며 다익스트라와 같은 점화식으로 최단 거리를 갱신한다.
    - 최단 거리를 갱신하는 과정을 정점의 개수만큼 반복한다.
3. 음수 싸이클 탐지
    - 모든 간선을 순회한 후 한 번 더 탐색을 진행하여 최단 거리가 또 갱신된다면 음수 사이클이 존재하는 것으로 확인한다.
```

### 3-3. 시간복잡도와 공간복잡도

그래프의 노드(점)의 수 = V, 간선의 수 = E

- 시간복잡도 
  - 모든 간선을 확인(E) * 정점 개수만큼 반복(V) == <span style = "color:skyblue">**O(VE)**</span>
- 공간복잡도
  - 한 정점에서 모든 정점으로 향하는 최단 거리를 저장 == O(V)

### 3-4. 문제 링크
- <a href = "https://www.acmicpc.net/problem/11657"> (타임머신 / 골드4) </a>
- <a href = "https://www.acmicpc.net/problem/1865"> (웜홀 / 골드3) </a>
